
# 2025-11-22 15:48:01.865118
+Code the following app
+```
+A slot machine with 3 columns and 3 rows, each slot contains one fruit. The fruits should be: Apple, Banana, Cherry, Lemon. Generate an vector style image with white background for each fruit and use it to display that fruit. The fruits should be spawned by the machine at random. The user can press the spin button, which will trigger a spinning animation that moves the columns downward, spawning new fruit at the top repeatedly for 2 seconds. If there are 3 of the same fruit in any row or column at any time while not spinning, display a win message to the user, which they can share on their feed. Check the win condition directly using a conditional render instead of calculating it in a function. The user should always be able to spin again, except while the spinning animation is in progress.
+
+Place the slot machine to the home page.
+```
+
+Generate an app logo and update the app metadata title and description.

# 2025-11-22 15:48:01.865861
+Code the following app
+```
+A slot machine with 3 columns and 3 rows, each slot contains one fruit. The fruits should be: Apple, Banana, Cherry, Lemon. Generate an vector style image with white background for each fruit and use it to display that fruit. The fruits should be spawned by the machine at random. The user can press the spin button, which will trigger a spinning animation that moves the columns downward, spawning new fruit at the top repeatedly for 2 seconds. If there are 3 of the same fruit in any row or column at any time while not spinning, display a win message to the user, which they can share on their feed. Check the win condition directly using a conditional render instead of calculating it in a function. The user should always be able to spin again, except while the spinning animation is in progress.
+
+Place the slot machine to the home page.
+```
+
+Generate an app logo and update the app metadata title and description.

# 2025-11-22 15:48:58.160573
+apply changes

# 2025-11-22 15:48:58.161152
+apply changes

# 2025-11-22 16:38:00.036248
+CHANGE YOUR APP NAME TO CRYPTO SLOTH AND PUT BTC, ETH, XRP, SOLANA, DOGE CRYPTOCURRENCY IMAGES INSTEAD OF THE FRUIT
+

# 2025-11-22 16:38:00.037058
+CHANGE YOUR APP NAME TO CRYPTO SLOTH AND PUT BTC, ETH, XRP, SOLANA, DOGE CRYPTOCURRENCY IMAGES INSTEAD OF THE FRUIT
+

# 2025-11-22 16:38:48.236324
+apply changes

# 2025-11-22 16:38:48.236662
+apply changes

# 2025-11-22 16:49:01.038451
+ARKA PLANI SİYAH RENGİNDE YAP

# 2025-11-22 16:49:01.050097
+ARKA PLANI SİYAH RENGİNDE YAP

# 2025-11-22 16:49:38.467151
+apply changes

# 2025-11-22 16:49:38.467748
+apply changes

# 2025-11-22 17:29:48.889995
+ERC-8021: Transaction Attribution
+A standardized method for attributing transactions to applications and wallets through data suffixes, enabling interoperable attribution tracking and reward distribution.
+
+Authors	
+Conner Swenberg (@ilikesymmetry)
+Created	2025-09-11
+Discussion Link	https://ethereum-magicians.org/t/erc-8021-transaction-attribution/25561
+Requires	
+ERC-4337
+
+EIP-5792
+
+Markdown
+
+https://raw.githubusercontent.com/ilikesymmetry/ER...
+Abstract
+This ERC defines a standardized method for attributing transactions to applications, wallets, and other entities through structured data suffixes appended to transaction calldata. The standard enables interoperable attribution tracking, supports multiple entity attribution per transaction, and provides a mechanism for reward distribution through registered payout addresses.
+
+Motivation
+Currently, applications informally append "data suffixes" to transactions to indicate their origin, typically using the first bytes of a hash representing the application name. For example, Coinbase adds keccak256("CoinbaseSmartWallet") to transactions from keys.coinbase.com, and apps like Zora and OpenSea employ similar approaches.
+
+This ad-hoc approach presents several limitations:
+
+Non-interoperable attribution: Each application uses custom suffix formats, requiring explicit checks for specific patterns to detect attributions
+Opaque identification: Hash-based suffixes obscure the actual application identity, making attribution analysis difficult
+Reward distribution challenges: Even when an application is identified, there's no standardized way to determine where to send rewards
+Limited multi-entity support: No clear mechanism for attributing transactions to multiple entities (e.g., both application and wallet)
+Lack of extensibility: No standardized way to query additional metadata about attributed entities
+This standard addresses these issues by providing a structured, extensible format for transaction attribution that supports multiple entities, reward distribution, and metadata discovery.
+
+Specification
+The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.
+
+Data Suffix Schema
+This standard defines a structured data suffix format appended to transaction calldata. The suffix consists of the following components (ordered from end of calldata backwards):
+
+ercSuffix (16 bytes): A special identifier value indicating use of this standard ("8021" repeated)
+schemaId (1 byte): Schema ID number that declares the schema of proceeding bytes with space for forwards compatibility
+schemaData (variable bytes): Data to be parsed according to schemaId
+A schemaId MUST have an associated ERC to be considered valid.
+
+Multi-Attribution Schemas
+Our first schemas enable attributing multiple entities in a single transaction.
+
+Entities are identified by a unique "code" which is a string that follows 7-bit ASCII encoding. A code MUST NOT contain commas (0x2C) as this is reserved as a delimitter for attributing multiple codes.
+
+Codes MUST also be registered in a Code Regsitry smart contract (interface defined in later section). Chains are encouraged to provide canonical code registries which MAY be defined in this or future ERCs.
+
+Schema ID 0 defines the following bytes and assumes chain's canonical Code Registry:
+
+codesLength (1 byte): Length of the codes array in bytes, including delimiters
+codes (variable length): Array of attribution codes using ASCII encoding with comma (0x2C) as delimiter
+Schema ID 1 builds on top of 0, but also defines a custom Code Registry chain and address
+
+codesLength (1 byte): Length of the codes array in bytes, including delimiters
+codes (variable length): Array of attribution codes using ASCII encoding with comma (0x2C) as delimiter
+codeRegistryChainIdLength (1 byte): Length of the chain id hosting the custom Code Registry
+codeRegistryChainId (variable bytes): Chain id hosting the custom Code Registry
+codeRegistryAddress (20 bytes): Address of a smart contract implementing ICodeRegistry
+Custom Code Registries can be referenced across chains for ease of connecting identity for multi-chain apps.
+
+Examples
+The complete suffix format is:
+
+{txData}{schemaData}{schemaId}{ercSuffix}
+Single entity attribution with canonical registry:
+
+{txData}{"baseapp"}{7}{0}{0x80218021802180218021802180218021}
+Multiple entity attribution with custom registry:
+
+{txData}{0xCodeRegistry}{8453}{2}{"baseapp,morpho"}{14}{1}{0x80218021802180218021802180218021}
+Parsing Algorithm
+Offchain parsers SHOULD implement the following algorithm:
+
+Extract the last TBD bytes as ercSuffix and verify it matches the standard identifier
+Extract the previous byte as schemaId
+If schemaId is 0: a. Extract the previous byte as codesLength b. Extract the previous codesLength bytes as codes c. Implicitly set codeRegistryAddress as the registry defined by the host chain d. Parse codes using 0x2C (comma) as delimiter between codes e. Query code-related data from codeRegistryAddress on host chain
+If schemaId is 1: a. Extract the previous byte as codesLength b. Extract the previous codesLength bytes as codes c. Extract the previous byte as codeRegistryChainIdLength d. Extract the previous codeRegistryChainIdLength bytes as codeRegistryChainId e. Extract the previous 20 bytes as codeRegistryAddress f. Parse codes using 0x2C (comma) as delimiter between codes g. Query code-related data from codeRegistryAddress on chain with id codeRegistryChainId
+Else schemaId does not match, parsing SHOULD terminate (unknown schemaId)
+Code Registry Interface
+A Code Registry MUST implement the following interface:
+
+interface ICodeRegistry {
+    /// @notice Fetch a code's address to payout incentives
+    /// @param code The code to query
+    /// @return The address to receive rewards for this code
+    function payoutAddress(string memory code) external view returns (address);
+    
+    /// @notice Fetch a code's URI to fetch for additional metadata
+    /// @param code The code to query  
+    /// @return The URI pointing to metadata about this code
+    function codeURI(string memory code) external view returns (string memory);
+    
+    /// @notice Check if a code is valid format (characters, length, etc)
+    /// @dev MUST return false if code is empty string
+    /// @param code The code to query
+    /// @return True if the code is valid, false otherwise
+    function isValidCode(string memory code) external view returns (bool);
+    
+    /// @notice Check if a code is registered
+    /// @param code The code to query
+    /// @return True if the code is registered, false otherwise
+    function isRegistered(string memory code) external view returns (bool);
+}
+Code Regsitry Canonical Addresses
+Chain ID	Code Registry
+8453	TBD
+84532	TBD
+Code Metadata
+Querying CodeRegistry.codeURI(code) returns a string uri to fetch actual metadata, following from NFT patterns. The returned metadata SHOULD include these fields:
+
+type CodeMetadata = {
+    app: {
+      name: string
+      url: string
+    }
+}
+Future ERCs can extend this schema.
+
+ERC-5792 Integration
+Applications using ERC-5792's wallet_sendCalls RPC method MUST communicate attribution data through a new capability:
+
+interface DataSuffixCapability {
+  dataSuffix: string; // Hex-encoded bytes to append as suffix
+}
+Wallets implementing this capability MUST append the provided dataSuffix bytes to the transaction calldata. Wallets MAY optionally insert their own attribution code before the application's suffix if they understand this standard.
+
+ERC-4337 User Operation Implementation
+For ERC-4337 compliant smart accounts, the implementation differs from normal Ethereum transactions:
+
+Normal Transactions: The attribution suffix is appended to the data field of the top-level Ethereum transaction.
+
+ERC-4337 User Operations: The attribution suffix MUST be appended to the userOp.callData field instead of the transaction-level data field, since smart account transactions are executed through the EntryPoint contract where the actual call data is contained within the user operation structure.
+
+When implementing attribution for smart accounts:
+
+Applications SHOULD append the suffix to userOp.callData when constructing user operations
+Parsers MUST examine the callData field of user operations rather than transaction data when processing ERC-4337 transactions
+Wallets supporting both EOA and smart account transactions MUST handle suffix appending appropriately based on the account type
+This ensures attribution data remains accessible and parseable regardless of whether the transaction originates from an externally owned account (EOA) or a smart contract account following ERC-4337.
+
+Rationale
+Design Decisions
+Reverse-order parsing: The suffix format is designed for parsing from the end of calldata backwards, enabling efficient detection of attribution without requiring knowledge of the original calldata length.
+
+schemaId byte: Including a schemaId field enables future extensions and optimizations in minimizing attribution data.
+
+Registry pattern: Using a registry contract allows entities to update their payout addresses and metadata without requiring transaction format changes.
+
+ASCII encoding: Using human-readable ASCII codes improves debuggability and allows for meaningful code names rather than opaque hashes.
+
+ERC-5792 integration: The capability-based approach aligns with ERC-5792's extensible design while providing a clean separation of concerns between applications and wallets.
+
+Alternative Approaches Considered
+Customizable registry: While a single global registry is recommended when available for reduced transaction data, the flexible registry approach allows different ecosystems to maintain their own attribution systems.
+
+Fixed-length codes: A fixed-length encoding was considered but rejected to allow for flexible, human-readable identifiers.
+
+ERC-721 dependency: While codes may be implemented as ERC-721 NFTs, reducing strict dependencies makes this proposal more flexible and clarifies the minimal interface truly required for attribution.
+
+Structured ERC-5792 capability: A generic bytes dataSuffix minimizes the effort on wallets to integrate and maintain support for new schemaIds, increasing chances of wide adoption.
+
+Backwards Compatibility
+This standard is fully backward compatible with existing transaction formats. Transactions without attribution suffixes continue to function normally, and the presence of attribution data does not affect transaction execution.
+
+Existing applications using informal attribution methods can migrate to this standard while maintaining their current functionality during the transition period.
+
+Security Considerations
+Parsing Safety
+Parsers MUST validate the suffix format before processing to prevent malformed data from causing errors. Invalid suffixes SHOULD be ignored rather than causing parsing failures.
+
+Registry Trust
+The security of attribution data depends on the trustworthiness of the registry contract. Users and applications SHOULD verify the registry implementation and governance before relying on its data.
+
+Data Integrity
+Since attribution data is appended to calldata, it could potentially be modified by intermediaries. Applications requiring cryptographic proof of attribution should implement additional signature-based verification mechanisms.
+
+Privacy Considerations
+Attribution data is publicly visible on-chain. Applications handling sensitive user information SHOULD NOT include identifying information in attribution codes.
+
+Test Cases
+Single entity attribution + canonical registry:
+
+Input: 0xdddddddd62617365617070070080218021802180218021802180218021
+Expected: 
+- txData: 0xdddddddd
+- schemaId: 0
+- codes: ["baseapp"]
+- registry: canonical
+Multiple entity attribution + custom registry:
+
+Input: 0xddddddddcccccccccccccccccccccccccccccccccccccccc210502626173656170702C6D6F7270686F0E0180218021802180218021802180218021
+Expected:
+- txData: 0xdddddddd
+- schemaId: 1
+- codes: ["baseapp", "morpho"]
+- codeRegistryChainId: 8453
+- codeRegistryAddress: 0xcccccccccccccccccccccccccccccccccccccccc
+Invalid schemaId handling:
+
+Input: 0xddddddddff80218021802180218021802180218021
+Expected: Parsing stops, unknown schemaId  CryptoQ'ya ERC-8021 entegrasyonu ekleye VE CUZDAN ADRESİ 0x29536D0bc1004ab274c4F0F59734Ad74D4559b7B
+
+

# 2025-11-22 17:29:48.891649
+ERC-8021: Transaction Attribution
+A standardized method for attributing transactions to applications and wallets through data suffixes, enabling interoperable attribution tracking and reward distribution.
+
+Authors	
+Conner Swenberg (@ilikesymmetry)
+Created	2025-09-11
+Discussion Link	https://ethereum-magicians.org/t/erc-8021-transaction-attribution/25561
+Requires	
+ERC-4337
+
+EIP-5792
+
+Markdown
+
+https://raw.githubusercontent.com/ilikesymmetry/ER...
+Abstract
+This ERC defines a standardized method for attributing transactions to applications, wallets, and other entities through structured data suffixes appended to transaction calldata. The standard enables interoperable attribution tracking, supports multiple entity attribution per transaction, and provides a mechanism for reward distribution through registered payout addresses.
+
+Motivation
+Currently, applications informally append "data suffixes" to transactions to indicate their origin, typically using the first bytes of a hash representing the application name. For example, Coinbase adds keccak256("CoinbaseSmartWallet") to transactions from keys.coinbase.com, and apps like Zora and OpenSea employ similar approaches.
+
+This ad-hoc approach presents several limitations:
+
+Non-interoperable attribution: Each application uses custom suffix formats, requiring explicit checks for specific patterns to detect attributions
+Opaque identification: Hash-based suffixes obscure the actual application identity, making attribution analysis difficult
+Reward distribution challenges: Even when an application is identified, there's no standardized way to determine where to send rewards
+Limited multi-entity support: No clear mechanism for attributing transactions to multiple entities (e.g., both application and wallet)
+Lack of extensibility: No standardized way to query additional metadata about attributed entities
+This standard addresses these issues by providing a structured, extensible format for transaction attribution that supports multiple entities, reward distribution, and metadata discovery.
+
+Specification
+The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.
+
+Data Suffix Schema
+This standard defines a structured data suffix format appended to transaction calldata. The suffix consists of the following components (ordered from end of calldata backwards):
+
+ercSuffix (16 bytes): A special identifier value indicating use of this standard ("8021" repeated)
+schemaId (1 byte): Schema ID number that declares the schema of proceeding bytes with space for forwards compatibility
+schemaData (variable bytes): Data to be parsed according to schemaId
+A schemaId MUST have an associated ERC to be considered valid.
+
+Multi-Attribution Schemas
+Our first schemas enable attributing multiple entities in a single transaction.
+
+Entities are identified by a unique "code" which is a string that follows 7-bit ASCII encoding. A code MUST NOT contain commas (0x2C) as this is reserved as a delimitter for attributing multiple codes.
+
+Codes MUST also be registered in a Code Regsitry smart contract (interface defined in later section). Chains are encouraged to provide canonical code registries which MAY be defined in this or future ERCs.
+
+Schema ID 0 defines the following bytes and assumes chain's canonical Code Registry:
+
+codesLength (1 byte): Length of the codes array in bytes, including delimiters
+codes (variable length): Array of attribution codes using ASCII encoding with comma (0x2C) as delimiter
+Schema ID 1 builds on top of 0, but also defines a custom Code Registry chain and address
+
+codesLength (1 byte): Length of the codes array in bytes, including delimiters
+codes (variable length): Array of attribution codes using ASCII encoding with comma (0x2C) as delimiter
+codeRegistryChainIdLength (1 byte): Length of the chain id hosting the custom Code Registry
+codeRegistryChainId (variable bytes): Chain id hosting the custom Code Registry
+codeRegistryAddress (20 bytes): Address of a smart contract implementing ICodeRegistry
+Custom Code Registries can be referenced across chains for ease of connecting identity for multi-chain apps.
+
+Examples
+The complete suffix format is:
+
+{txData}{schemaData}{schemaId}{ercSuffix}
+Single entity attribution with canonical registry:
+
+{txData}{"baseapp"}{7}{0}{0x80218021802180218021802180218021}
+Multiple entity attribution with custom registry:
+
+{txData}{0xCodeRegistry}{8453}{2}{"baseapp,morpho"}{14}{1}{0x80218021802180218021802180218021}
+Parsing Algorithm
+Offchain parsers SHOULD implement the following algorithm:
+
+Extract the last TBD bytes as ercSuffix and verify it matches the standard identifier
+Extract the previous byte as schemaId
+If schemaId is 0: a. Extract the previous byte as codesLength b. Extract the previous codesLength bytes as codes c. Implicitly set codeRegistryAddress as the registry defined by the host chain d. Parse codes using 0x2C (comma) as delimiter between codes e. Query code-related data from codeRegistryAddress on host chain
+If schemaId is 1: a. Extract the previous byte as codesLength b. Extract the previous codesLength bytes as codes c. Extract the previous byte as codeRegistryChainIdLength d. Extract the previous codeRegistryChainIdLength bytes as codeRegistryChainId e. Extract the previous 20 bytes as codeRegistryAddress f. Parse codes using 0x2C (comma) as delimiter between codes g. Query code-related data from codeRegistryAddress on chain with id codeRegistryChainId
+Else schemaId does not match, parsing SHOULD terminate (unknown schemaId)
+Code Registry Interface
+A Code Registry MUST implement the following interface:
+
+interface ICodeRegistry {
+    /// @notice Fetch a code's address to payout incentives
+    /// @param code The code to query
+    /// @return The address to receive rewards for this code
+    function payoutAddress(string memory code) external view returns (address);
+    
+    /// @notice Fetch a code's URI to fetch for additional metadata
+    /// @param code The code to query  
+    /// @return The URI pointing to metadata about this code
+    function codeURI(string memory code) external view returns (string memory);
+    
+    /// @notice Check if a code is valid format (characters, length, etc)
+    /// @dev MUST return false if code is empty string
+    /// @param code The code to query
+    /// @return True if the code is valid, false otherwise
+    function isValidCode(string memory code) external view returns (bool);
+    
+    /// @notice Check if a code is registered
+    /// @param code The code to query
+    /// @return True if the code is registered, false otherwise
+    function isRegistered(string memory code) external view returns (bool);
+}
+Code Regsitry Canonical Addresses
+Chain ID	Code Registry
+8453	TBD
+84532	TBD
+Code Metadata
+Querying CodeRegistry.codeURI(code) returns a string uri to fetch actual metadata, following from NFT patterns. The returned metadata SHOULD include these fields:
+
+type CodeMetadata = {
+    app: {
+      name: string
+      url: string
+    }
+}
+Future ERCs can extend this schema.
+
+ERC-5792 Integration
+Applications using ERC-5792's wallet_sendCalls RPC method MUST communicate attribution data through a new capability:
+
+interface DataSuffixCapability {
+  dataSuffix: string; // Hex-encoded bytes to append as suffix
+}
+Wallets implementing this capability MUST append the provided dataSuffix bytes to the transaction calldata. Wallets MAY optionally insert their own attribution code before the application's suffix if they understand this standard.
+
+ERC-4337 User Operation Implementation
+For ERC-4337 compliant smart accounts, the implementation differs from normal Ethereum transactions:
+
+Normal Transactions: The attribution suffix is appended to the data field of the top-level Ethereum transaction.
+
+ERC-4337 User Operations: The attribution suffix MUST be appended to the userOp.callData field instead of the transaction-level data field, since smart account transactions are executed through the EntryPoint contract where the actual call data is contained within the user operation structure.
+
+When implementing attribution for smart accounts:
+
+Applications SHOULD append the suffix to userOp.callData when constructing user operations
+Parsers MUST examine the callData field of user operations rather than transaction data when processing ERC-4337 transactions
+Wallets supporting both EOA and smart account transactions MUST handle suffix appending appropriately based on the account type
+This ensures attribution data remains accessible and parseable regardless of whether the transaction originates from an externally owned account (EOA) or a smart contract account following ERC-4337.
+
+Rationale
+Design Decisions
+Reverse-order parsing: The suffix format is designed for parsing from the end of calldata backwards, enabling efficient detection of attribution without requiring knowledge of the original calldata length.
+
+schemaId byte: Including a schemaId field enables future extensions and optimizations in minimizing attribution data.
+
+Registry pattern: Using a registry contract allows entities to update their payout addresses and metadata without requiring transaction format changes.
+
+ASCII encoding: Using human-readable ASCII codes improves debuggability and allows for meaningful code names rather than opaque hashes.
+
+ERC-5792 integration: The capability-based approach aligns with ERC-5792's extensible design while providing a clean separation of concerns between applications and wallets.
+
+Alternative Approaches Considered
+Customizable registry: While a single global registry is recommended when available for reduced transaction data, the flexible registry approach allows different ecosystems to maintain their own attribution systems.
+
+Fixed-length codes: A fixed-length encoding was considered but rejected to allow for flexible, human-readable identifiers.
+
+ERC-721 dependency: While codes may be implemented as ERC-721 NFTs, reducing strict dependencies makes this proposal more flexible and clarifies the minimal interface truly required for attribution.
+
+Structured ERC-5792 capability: A generic bytes dataSuffix minimizes the effort on wallets to integrate and maintain support for new schemaIds, increasing chances of wide adoption.
+
+Backwards Compatibility
+This standard is fully backward compatible with existing transaction formats. Transactions without attribution suffixes continue to function normally, and the presence of attribution data does not affect transaction execution.
+
+Existing applications using informal attribution methods can migrate to this standard while maintaining their current functionality during the transition period.
+
+Security Considerations
+Parsing Safety
+Parsers MUST validate the suffix format before processing to prevent malformed data from causing errors. Invalid suffixes SHOULD be ignored rather than causing parsing failures.
+
+Registry Trust
+The security of attribution data depends on the trustworthiness of the registry contract. Users and applications SHOULD verify the registry implementation and governance before relying on its data.
+
+Data Integrity
+Since attribution data is appended to calldata, it could potentially be modified by intermediaries. Applications requiring cryptographic proof of attribution should implement additional signature-based verification mechanisms.
+
+Privacy Considerations
+Attribution data is publicly visible on-chain. Applications handling sensitive user information SHOULD NOT include identifying information in attribution codes.
+
+Test Cases
+Single entity attribution + canonical registry:
+
+Input: 0xdddddddd62617365617070070080218021802180218021802180218021
+Expected: 
+- txData: 0xdddddddd
+- schemaId: 0
+- codes: ["baseapp"]
+- registry: canonical
+Multiple entity attribution + custom registry:
+
+Input: 0xddddddddcccccccccccccccccccccccccccccccccccccccc210502626173656170702C6D6F7270686F0E0180218021802180218021802180218021
+Expected:
+- txData: 0xdddddddd
+- schemaId: 1
+- codes: ["baseapp", "morpho"]
+- codeRegistryChainId: 8453
+- codeRegistryAddress: 0xcccccccccccccccccccccccccccccccccccccccc
+Invalid schemaId handling:
+
+Input: 0xddddddddff80218021802180218021802180218021
+Expected: Parsing stops, unknown schemaId  CryptoQ'ya ERC-8021 entegrasyonu ekleye VE CUZDAN ADRESİ 0x29536D0bc1004ab274c4F0F59734Ad74D4559b7B
+
+

# 2025-11-22 17:31:15.686085
+apply changes

# 2025-11-22 17:31:15.686650
+apply changes
